Skip to content
You said:
import random

def random_chromosome(size): #making random chromosomes
    return [ random.randint(1, nq) for _ in range(nq) ]

def fitness(chromosome):
    horizontal_collisions = sum([chromosome.count(queen)-1 for queen in chromosome])/2
    diagonal_collisions = 0

    n = len(chromosome)
    left_diagonal = [0] * 2*n
    right_diagonal = [0] * 2*n
    for i in range(n):
        left_diagonal[i + chromosome[i] - 1] += 1
        right_diagonal[len(chromosome) - i + chromosome[i] - 2] += 1

    diagonal_collisions = 0
    for i in range(2*n-1):
        counter = 0
        if left_diagonal[i] > 1:
            counter += left_diagonal[i]-1
        if right_diagonal[i] > 1:
            counter += right_diagonal[i]-1
        diagonal_collisions += counter / (n-abs(i-n+1))

    return int(maxFitness - (horizontal_collisions + diagonal_collisions)) #28-(2+3)=23

def probability(chromosome, fitness):
    return fitness(chromosome) / maxFitness

def random_pick(population, probabilities):
    populationWithProbabilty = zip(population, probabilities)
    total = sum(w for c, w in populationWithProbabilty)
    r = random.uniform(0, total)
    upto = 0
    for c, w in zip(population, probabilities):
        if upto + w >= r:
            return c
        upto += w
    assert False, "Shouldn't get here"

def reproduce(x, y): #doing cross_over between two chromosomes
    n = len(x)
    c = random.randint(0, n - 1)
    return x[0:c] + y[c:n]

def mutate(x):  #randomly changing the value of a random index of a chromosome
    n = len(x)
    c = random.randint(0, n - 1)
    m = random.randint(1, n)
    x[c] = m
    return x

def genetic_queen(population, fitness):
    mutation_probability = 0.03
    new_population = []
    probabilities = [probability(n, fitness) for n in population]
    for i in range(len(population)):
        x = random_pick(population, probabilities) #best chromosome 1
        y = random_pick(population, probabilities) #best chromosome 2
        child = reproduce(x, y) #creating two new chromosomes from the best 2 chromosomes
        if random.random() < mutation_probability:
            child = mutate(child)
        print_chromosome(child)
        new_population.append(child)
        if fitness(child) == maxFitness: break
    return new_population

def print_chromosome(chrom):
    print("Chromosome = {},  Fitness = {}"
        .format(str(chrom), fitness(chrom)))

if __name__ == "__main__":
    nq = int(input("Enter Number of Queens: ")) #say N = 8
    maxFitness = (nq*(nq-1))/2  # 8*7/2 = 28
    population = [random_chromosome(nq) for _ in range(100)]

    generation = 1

    while not maxFitness in [fitness(chrom) for chrom in population]:
        print("=== Generation {} ===".format(generation))
        population = genetic_queen(population, fitness)
        print("")
        print("Maximum Fitness = {}".format(max([fitness(n) for n in population])))
        generation += 1
    chrom_out = []
    print("Solved in Generation {}!".format(generation-1))
    for chrom in population:
        if fitness(chrom) == maxFitness:
            print("")
            print("One of the solutions: ")
            chrom_out = chrom
            print_chromosome(chrom)

    board = []

    for x in range(nq):
        board.append(["x"] * nq)

    for i in range(nq):
        board[nq-chrom_out[i]][i]="Q"


    def print_board(board):
        for row in board:
            print (" ".join(row))

    print()
    print_board(board)





explain the code in bangla with proper details
ChatGPT said:
à¦à¦‡ à¦•à§‹à¦¡à¦Ÿà¦¿ à¦¹à¦²à§‹ Genetic Algorithm à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à§‡ N-Queens Problem à¦¸à¦®à¦¾à¦§à¦¾à¦¨à§‡à¦° à¦à¦•à¦Ÿà¦¿ à¦¬à¦¾à¦¸à§à¦¤à¦¬à¦¾à¦¯à¦¼à¦¨ (implementation)à¥¤ à¦¨à¦¿à¦šà§‡ à¦§à¦¾à¦ªà§‡ à¦§à¦¾à¦ªà§‡ à¦¬à¦¾à¦‚à¦²à¦¾à¦¯à¦¼ à¦¬à§à¦¯à¦¾à¦–à§à¦¯à¦¾ à¦•à¦°à¦¾ à¦¹à¦²à§‹:

ðŸ” à¦¸à¦®à¦¸à§à¦¯à¦¾à¦° à¦¸à¦‚à¦•à§à¦·à¦¿à¦ªà§à¦¤ à¦¬à¦¿à¦¬à¦°à¦£:
N-Queens Problem: à¦à¦•à¦Ÿà¦¿ N x N à¦¬à§‹à¦°à§à¦¡à§‡ Nà¦Ÿà¦¿ à¦°à¦¾à¦¨à§€ à¦à¦®à¦¨à¦­à¦¾à¦¬à§‡ à¦¬à¦¸à¦¾à¦¤à§‡ à¦¹à¦¬à§‡ à¦¯à§‡à¦¨ à¦¤à¦¾à¦°à¦¾ à¦à¦•à§‡ à¦…à¦ªà¦°à¦•à§‡ à¦†à¦•à§à¦°à¦®à¦£ à¦•à¦°à¦¤à§‡ à¦¨à¦¾ à¦ªà¦¾à¦°à§‡à¥¤ à¦…à¦°à§à¦¥à¦¾à§Ž, à¦•à§‹à¦¨à§‹ à¦¦à§à¦‡ à¦°à¦¾à¦¨à§€ à¦à¦•à¦‡ à¦¸à¦¾à¦°à¦¿, à¦•à¦²à¦¾à¦® à¦¬à¦¾ à¦•à¦°à§à¦£à§‡ à¦¥à¦¾à¦•à¦¤à§‡ à¦ªà¦¾à¦°à¦¬à§‡ à¦¨à¦¾à¥¤

ðŸ§  à¦•à§‹à¦¡ à¦¬à¦¿à¦¶à§à¦²à§‡à¦·à¦£:
âœ… 1. random_chromosome(size)
return [ random.randint(1, nq) for _ in range(nq) ]
à¦à¦Ÿà¦¿ à¦à¦•à¦Ÿà¦¿ à¦à¦²à§‹à¦®à§‡à¦²à§‹ à¦¸à¦®à¦¾à¦§à¦¾à¦¨ à¦¤à§ˆà¦°à¦¿ à¦•à¦°à§‡, à¦¯à§‡à¦–à¦¾à¦¨à§‡ à¦à¦•à¦Ÿà¦¿ list à¦¥à¦¾à¦•à§‡ nq à¦¸à¦‚à¦–à§à¦¯à¦• à¦°à¦¾à¦¨à§€à¦° à¦œà¦¨à§à¦¯à¥¤

à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ à¦‡à¦¨à§à¦¡à§‡à¦•à§à¦¸ à¦¬à§‹à¦à¦¾à§Ÿ à¦à¦•à¦Ÿà¦¿ column, à¦†à¦° à¦¤à¦¾à¦° à¦®à¦¾à¦¨ à¦¬à§‹à¦à¦¾à§Ÿ rowà¥¤

à¦‰à¦¦à¦¾à¦¹à¦°à¦£: [4, 2, 7, 3, 6, 8, 5, 1] â€” à¦®à¦¾à¦¨à§‡ à¦¹à¦šà§à¦›à§‡ 1à¦® à¦•à¦²à¦¾à¦®à§‡ à¦°à¦¾à¦¨à§€ à¦†à¦›à§‡ 4 à¦¨à¦®à§à¦¬à¦° à¦¸à¦¾à¦°à¦¿à¦¤à§‡, 2à§Ÿ à¦•à¦²à¦¾à¦®à§‡ 2 à¦¨à¦®à§à¦¬à¦° à¦¸à¦¾à¦°à¦¿à¦¤à§‡ à¦‡à¦¤à§à¦¯à¦¾à¦¦à¦¿à¥¤

âœ… 2. fitness(chromosome)
return int(maxFitness - (horizontal_collisions + diagonal_collisions))
à¦à¦•à¦Ÿà¦¿ chromosome (à¦¸à¦®à§à¦­à¦¾à¦¬à§à¦¯ à¦¸à¦®à¦¾à¦§à¦¾à¦¨) à¦•à¦¤à¦Ÿà¦¾ à¦­à¦¾à¦²à§‹ à¦¤à¦¾ à¦¨à¦¿à¦°à§à¦§à¦¾à¦°à¦£ à¦•à¦°à§‡à¥¤

à¦¦à§à¦Ÿà¦¿ à¦§à¦°à¦£à§‡à¦° à¦•à¦¨à¦«à§à¦²à¦¿à¦•à§à¦Ÿ à¦šà§‡à¦• à¦•à¦°à§‡:

Horizontal Collisions (à¦à¦•à¦‡ à¦¸à¦¾à¦°à¦¿à¦¤à§‡ à¦à¦•à¦¾à¦§à¦¿à¦• à¦°à¦¾à¦¨à§€)

Diagonal Collisions (à¦¡à¦¾à¦¨ à¦¬à¦¾ à¦¬à¦¾à¦ à¦•à¦°à§à¦£à§‡ à¦¥à¦¾à¦•à¦¾ à¦°à¦¾à¦¨à§€)

à¦¯à¦¤ à¦•à¦® à¦•à¦¨à¦«à§à¦²à¦¿à¦•à§à¦Ÿ, à¦¤à¦¤ à¦¬à§‡à¦¶à¦¿ à¦«à¦¿à¦Ÿà¦¨à§‡à¦¸à¥¤

à¦²à¦•à§à¦·à§à¦¯: maxFitness = nq * (nq - 1) / 2 (à¦•à§‹à¦¨à§‹ à¦•à¦¨à¦«à§à¦²à¦¿à¦•à§à¦Ÿ à¦¨à¦¾ à¦¥à¦¾à¦•à¦²à§‡ à¦à¦‡ à¦®à¦¾à¦¨ à¦¹à§Ÿ)

âœ… 3. probability(chromosome, fitness)
return fitness(chromosome) / maxFitness
à¦à¦•à¦Ÿà¦¿ chromosome à¦à¦° à¦«à¦¿à¦Ÿà¦¨à§‡à¦¸à¦•à§‡ à¦®à§‹à¦Ÿ à¦«à¦¿à¦Ÿà¦¨à§‡à¦¸ à¦¦à¦¿à§Ÿà§‡ à¦­à¦¾à¦— à¦•à¦°à§‡ à¦¸à¦®à§à¦­à¦¾à¦¬à§à¦¯à¦¤à¦¾ à¦¬à§‡à¦° à¦•à¦°à§‡à¥¤

âœ… 4. random_pick(population, probabilities)
roulette-wheel selection à¦…à¦¨à§à¦¯à¦¾à§Ÿà§€ à¦à¦²à§‹à¦®à§‡à¦²à§‹à¦­à¦¾à¦¬à§‡ à¦¦à§à¦Ÿà¦¿ chromosome à¦¬à§‡à¦›à§‡ à¦¨à§‡à§Ÿà¥¤

à¦¯à¦¾à¦¦à§‡à¦° à¦«à¦¿à¦Ÿà¦¨à§‡à¦¸ à¦¬à§‡à¦¶à¦¿, à¦¤à¦¾à¦¦à§‡à¦° à¦¨à¦¿à¦°à§à¦¬à¦¾à¦šà¦¿à¦¤ à¦¹à¦¬à¦¾à¦° à¦¸à¦®à§à¦­à¦¾à¦¬à¦¨à¦¾ à¦¬à§‡à¦¶à¦¿à¥¤

âœ… 5. reproduce(x, y)
c = random.randint(0, n - 1)
return x[0:c] + y[c:n]
x à¦“ y à¦¦à§à¦Ÿà¦¿ parent chromosome à¦¥à§‡à¦•à§‡ à¦à¦•à¦Ÿà¦¿à¦•à§‡ à¦•à§‡à¦Ÿà§‡ à¦…à¦ªà¦°à¦Ÿà¦¿à¦° à¦…à¦‚à¦¶ à¦œà§à§œà§‡ à¦¦à§‡à§Ÿ â†’ crossoverà¥¤

âœ… 6. mutate(x)
c = random.randint(0, n - 1)
m = random.randint(1, n)
x[c] = m
return x
mutation à¦¬à¦¾ à¦¹à¦ à¦¾à§Ž à¦ªà¦°à¦¿à¦¬à¦°à§à¦¤à¦¨à¥¤ à¦à¦•à¦Ÿà¦¿ à¦‡à¦¨à§à¦¡à§‡à¦•à§à¦¸à§‡ à¦¨à¦¤à§à¦¨ à¦à¦²à§‹à¦®à§‡à¦²à§‹ row à¦¬à¦¸à¦¾à¦¨à§‹ à¦¹à§Ÿà¥¤

âœ… 7. genetic_queen(population, fitness)
à¦®à§‚à¦² genetic algorithm à¦«à¦¾à¦‚à¦¶à¦¨à¥¤

à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ à¦ªà§à¦°à¦œà¦¨à§à¦®à§‡:

à¦­à¦¾à¦² à¦¦à§à¦Ÿà¦¿ chromosome à¦¬à§‡à¦›à§‡ à¦¨à§‡à§Ÿ

à¦¤à¦¾à¦¦à§‡à¦° crossover à¦•à¦°à§‡ child à¦¤à§ˆà¦°à¦¿ à¦•à¦°à§‡

à¦¸à¦®à§à¦­à¦¬ à¦¹à¦²à§‡ mutation à¦•à¦°à§‡

à¦«à¦¿à¦Ÿà¦¨à§‡à¦¸ à¦­à¦¾à¦²à§‹ child à¦¥à¦¾à¦•à¦²à§‡ à¦¸à¦‚à¦°à¦•à§à¦·à¦£ à¦•à¦°à§‡

à¦²à¦•à§à¦·à§à¦¯: à¦à¦®à¦¨ à¦à¦•à¦Ÿà¦¾ à¦¸à¦®à¦¾à¦§à¦¾à¦¨ à¦ªà¦¾à¦“à§Ÿà¦¾ à¦¯à¦¾à¦° à¦«à¦¿à¦Ÿà¦¨à§‡à¦¸ maxFitness à¦à¦° à¦¸à¦®à¦¾à¦¨à¥¤

âœ… 8. print_chromosome(chrom)
print("Chromosome = {},  Fitness = {}".format(str(chrom), fitness(chrom)))
à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ chromosome à¦à¦¬à¦‚ à¦¤à¦¾à¦° à¦«à¦¿à¦Ÿà¦¨à§‡à¦¸ à¦ªà§à¦°à¦¿à¦¨à§à¦Ÿ à¦•à¦°à§‡à¥¤

ðŸ”„ à¦®à§‚à¦² Execution Flow:
while not maxFitness in [fitness(chrom) for chrom in population]:
à¦¯à¦¤à¦•à§à¦·à¦£ à¦ªà¦°à§à¦¯à¦¨à§à¦¤ perfect à¦¸à¦®à¦¾à¦§à¦¾à¦¨ (maximum fitness) à¦¨à¦¾ à¦ªà¦¾à¦“à§Ÿà¦¾ à¦¯à¦¾à§Ÿ, à¦¤à¦¤à¦•à§à¦·à¦£ loop à¦šà¦²à§‡à¥¤

ðŸ à¦¸à¦®à¦¾à¦§à¦¾à¦¨ à¦ªà¦¾à¦“à§Ÿà¦¾à¦° à¦ªà¦°:
for i in range(nq):
    board[nq - chrom_out[i]][i] = "Q"
à¦ªà¦¾à¦“à§Ÿà¦¾ à¦—à¦¿à§Ÿà§‡à¦›à§‡ à¦à¦®à¦¨ à¦à¦•à¦Ÿà¦¿ à¦¸à¦®à¦¾à¦§à¦¾à¦¨à¦•à§‡ chessboard à¦†à¦•à¦¾à¦°à§‡ à¦¦à§‡à¦–à¦¾à§Ÿà¥¤ à¦°à¦¾à¦¨à§€ à¦¬à¦¸à¦¾à¦¨à§‹ à¦¹à§Ÿ Q à¦¦à¦¿à§Ÿà§‡à¥¤

ðŸ–¨ï¸ à¦šà§‚à§œà¦¾à¦¨à§à¦¤ à¦¬à§‹à¦°à§à¦¡ à¦ªà§à¦°à¦¿à¦¨à§à¦Ÿ:
def print_board(board):
    for row in board:
        print(" ".join(row))
à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ à¦¸à¦¾à¦°à¦¿ à¦†à¦²à¦¾à¦¦à¦¾à¦­à¦¾à¦¬à§‡ à¦ªà§à¦°à¦¿à¦¨à§à¦Ÿ à¦•à¦°à§‡ à¦¬à§‹à¦°à§à¦¡ à¦†à¦•à¦¾à¦°à§‡ à¦¦à§‡à¦–à¦¾à§Ÿà¥¤

ðŸ§ª à¦‰à¦¦à¦¾à¦¹à¦°à¦£ à¦‡à¦¨à¦ªà§à¦Ÿ-à¦†à¦‰à¦Ÿà¦ªà§à¦Ÿ:
Input:

Enter Number of Queens: 8
Output (à¦¸à¦‚à¦•à§à¦·à§‡à¦ª):

Solved in Generation 4!
One of the solutions:
Chromosome = [1, 5, 8, 6, 3, 7, 2, 4],  Fitness = 28
Q x x x x x x x
x x x x Q x x x
x x x x x x x Q
x x x x x Q x x
x x Q x x x x x
x x x x x x Q x
x Q x x x x x x
x x x Q x x x x
âœ… à¦¸à¦‚à¦•à§à¦·à§‡à¦ªà§‡:
à¦à¦‡ à¦ªà§à¦°à§‹à¦—à§à¦°à¦¾à¦®à¦Ÿà¦¿ Genetic Algorithm à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à§‡ à¦§à¦¾à¦ªà§‡ à¦§à¦¾à¦ªà§‡ à¦¸à¦®à¦¾à¦§à¦¾à¦¨ à¦¤à§ˆà¦°à¦¿ à¦•à¦°à§‡ à¦à¦¬à¦‚ à¦§à§€à¦°à§‡ à¦§à§€à¦°à§‡ à¦­à¦¾à¦²à§‹ à¦¸à¦®à¦¾à¦§à¦¾à¦¨à§‡à¦° à¦¦à¦¿à¦•à§‡ à¦…à¦—à§à¦°à¦¸à¦° à¦¹à§Ÿà¥¤ à¦…à¦¬à¦¶à§‡à¦·à§‡, à¦à¦Ÿà¦¿ à¦à¦•à¦Ÿà¦¿ à¦¸à¦®à¦¾à¦§à¦¾à¦¨ à¦–à§à¦à¦œà§‡ à¦¬à§‡à¦° à¦•à¦°à§‡ à¦¯à§‡à¦–à¦¾à¦¨à§‡ Nà¦Ÿà¦¿ à¦°à¦¾à¦¨à§€ à¦à¦•à§‡ à¦…à¦ªà¦°à¦•à§‡ à¦†à¦•à§à¦°à¦®à¦£ à¦•à¦°à§‡ à¦¨à¦¾à¥¤

à¦†à¦ªà¦¨à¦¿ à¦šà¦¾à¦‡à¦²à§‡ à¦à¦‡ à¦•à§‹à¦¡à§‡ GUI visualization, à¦…à¦ªà§à¦Ÿà¦¿à¦®à¦¾à¦‡à¦œà¦¡ à¦®à¦¿à¦‰à¦Ÿà§‡à¦¶à¦¨ à¦¬à¦¾ à¦…à¦¨à§à¦¯ fitness à¦«à¦¾à¦‚à¦¶à¦¨ à¦¯à§à¦•à§à¦¤ à¦•à¦°à¦¤à§‡ à¦ªà¦¾à¦°à§‡à¦¨à¥¤
à¦†à¦ªà¦¨à¦¿ à¦•à§€ à¦à¦‡ à¦•à§‹à¦¡à§‡ à¦•à§‹à¦¨à§‹ à¦¨à¦¿à¦°à§à¦¦à¦¿à¦·à§à¦Ÿ à¦…à¦‚à¦¶à§‡ à¦ªà¦°à¦¿à¦¬à¦°à§à¦¤à¦¨ à¦¬à¦¾ à¦‰à¦¨à§à¦¨à§Ÿà¦¨ à¦•à¦°à¦¤à§‡ à¦šà¦¾à¦¨?

You said:
Single Point Crossover in Genetic Algorithm â€“ Python
Last Updated : 06 May, 2025
Single Point Crossover is a method used in a technique called genetic algorithms which are inspired by how living things pass on their traits to their children. Just like in nature where a child gets some traits from the mother and some from the father this method mixes two â€œparent solutionsâ€ to create new ones. This helps us to create better and stronger solutions by combining good parts from different options. There are four key steps in single point crossover:

Select Parents : Choose two parent chromosomes from population.
Choose a Crossover Point : Randomly select a position in chromosome.
Perform Crossover : Swaps the segments of parents after the crossover point to create two offspring.
Generate Offspring : Add new offspring to next generation.
This method ensures diversity in the population while preserving some genetic

def single_point_crossover(parent1, parent2):

    if len(parent1) != len(parent2):
        raise ValueError("Parents must have the same length.")

    crossover_point = random.randint(1, len(parent1) - 1)

    offspring1 = parent1[:crossover_point] + parent2[crossover_point:]
    offspring2 = parent2[:crossover_point] + parent1[crossover_point:]
    
    return offspring1, offspring2

parent1 = [1, 0, 1, 1, 0]
parent2 = [0, 1, 0, 1, 1]

offspring1, offspring2 = single_point_crossover(parent1, parent2)
print("Offspring 1:", offspring1)
print("Offspring 2:", offspring2)

explain these also
ChatGPT said:
à¦šà¦²à§à¦¨ à¦à¦–à¦¨ Single Point Crossover à¦à¦° à¦§à¦¾à¦°à¦£à¦¾ à¦“ Python à¦•à§‹à¦¡à¦Ÿà¦¿ à¦¬à¦¾à¦‚à¦²à¦¾à§Ÿ à¦¸à¦¹à¦œà¦­à¦¾à¦¬à§‡ à¦¬à§à¦¯à¦¾à¦–à§à¦¯à¦¾ à¦•à¦°à¦¿à¥¤

ðŸ§¬ Single Point Crossover (à¦à¦•à¦• à¦¬à¦¿à¦¨à§à¦¦à§ à¦•à§à¦°à¦¸à¦“à¦­à¦¾à¦°) à¦•à§€?
Single Point Crossover à¦¹à¦²à§‹ Genetic Algorithm-à¦à¦° à¦à¦•à¦Ÿà¦¿ à¦—à§à¦°à§à¦¤à§à¦¬à¦ªà§‚à¦°à§à¦£ à¦…à¦‚à¦¶, à¦¯à§‡à¦–à¦¾à¦¨à§‡ à¦¦à§à¦‡à¦Ÿà¦¿ parent (à¦…à¦­à¦¿à¦­à¦¾à¦¬à¦• à¦¸à¦®à¦¾à¦§à¦¾à¦¨) à¦¥à§‡à¦•à§‡ à¦¨à¦¤à§à¦¨ offspring (à¦¸à¦¨à§à¦¤à¦¾à¦¨) à¦¤à§ˆà¦°à¦¿ à¦•à¦°à¦¾ à¦¹à§Ÿà¥¤

à¦¯à§‡à¦®à¦¨ à¦ªà§à¦°à¦•à§ƒà¦¤à¦¿à¦¤à§‡ à¦¸à¦¨à§à¦¤à¦¾à¦¨ à¦®à¦¾-à¦¬à¦¾à¦¬à¦¾ à¦¥à§‡à¦•à§‡ à¦¬à§ˆà¦¶à¦¿à¦·à§à¦Ÿà§à¦¯ à¦ªà¦¾à§Ÿ, à¦¤à§‡à¦®à¦¨à¦¿à¦­à¦¾à¦¬à§‡ à¦à¦‡ à¦ªà¦¦à§à¦§à¦¤à¦¿à¦¤à§‡ à¦à¦• parent-à¦à¦° à¦•à¦¿à¦›à§ à¦…à¦‚à¦¶ à¦“ à¦…à¦ªà¦° parent-à¦à¦° à¦•à¦¿à¦›à§ à¦…à¦‚à¦¶ à¦®à¦¿à¦²à¦¿à§Ÿà§‡ à¦¨à¦¤à§à¦¨ à¦¸à¦®à¦¾à¦§à¦¾à¦¨ à¦¤à§ˆà¦°à¦¿ à¦•à¦°à¦¾ à¦¹à§Ÿà¥¤

ðŸ”‘ à¦—à§à¦°à§à¦¤à§à¦¬à¦ªà§‚à¦°à§à¦£ à¦§à¦¾à¦ªà¦—à§à¦²à§‹:
Select Parents (à¦ªà§à¦¯à¦¾à¦°à§‡à¦¨à§à¦Ÿ à¦¨à¦¿à¦°à§à¦¬à¦¾à¦šà¦¨):
à¦à¦²à§‹à¦®à§‡à¦²à§‹à¦­à¦¾à¦¬à§‡ à¦¦à§à¦‡à¦Ÿà¦¿ parent chromosome à¦¬à§‡à¦›à§‡ à¦¨à§‡à¦“à§Ÿà¦¾ à¦¹à§Ÿà¥¤

Choose a Crossover Point (à¦à¦•à¦Ÿà¦¿ à¦•à§à¦°à¦¸à¦“à¦­à¦¾à¦° à¦ªà¦¯à¦¼à§‡à¦¨à§à¦Ÿ à¦¨à¦¿à¦°à§à¦¬à¦¾à¦šà¦¨):
à¦à¦•à¦Ÿà¦¿ index (à¦¸à§à¦¥à¦¾à¦¨) à¦¬à§‡à¦›à§‡ à¦¨à§‡à¦“à§Ÿà¦¾ à¦¹à§Ÿ à¦¯à§‡à¦–à¦¾à¦¨à§‡ à¦¬à¦¿à¦­à¦¾à¦œà¦¨ à¦•à¦°à¦¾ à¦¹à¦¬à§‡à¥¤

Perform Crossover (à¦•à§à¦°à¦¸à¦“à¦­à¦¾à¦° à¦¸à¦®à§à¦ªà¦¨à§à¦¨):
à¦¸à§‡à¦‡ index à¦ªà¦°à§à¦¯à¦¨à§à¦¤ à¦ªà§à¦°à¦¥à¦® parent-à¦à¦° à¦…à¦‚à¦¶ à¦¨à§‡à¦“à§Ÿà¦¾ à¦¹à§Ÿ à¦à¦¬à¦‚ à¦¤à¦¾à¦°à¦ªà¦° à¦¦à§à¦¬à¦¿à¦¤à§€à§Ÿ parent-à¦à¦° à¦¬à¦¾à¦•à¦¿ à¦…à¦‚à¦¶ à¦œà§‹à§œà¦¾ à¦¹à§Ÿà¥¤

Generate Offspring (à¦¸à¦¨à§à¦¤à¦¾à¦¨ à¦¤à§ˆà¦°à¦¿):
à¦¦à§à¦‡à¦Ÿà¦¿ offspring à¦¤à§ˆà¦°à¦¿ à¦¹à§Ÿ (parent1+parent2 à¦à¦¬à¦‚ parent2+parent1 à¦¸à§à¦Ÿà¦¾à¦‡à¦²)à¥¤

âœ… à¦•à§‹à¦¡ à¦¬à¦¿à¦¶à§à¦²à§‡à¦·à¦£
def single_point_crossover(parent1, parent2):
    if len(parent1) != len(parent2):
        raise ValueError("Parents must have the same length.")
à¦ªà§à¦°à¦¥à¦®à§‡ à¦¦à§‡à¦–à¦¾ à¦¹à§Ÿ parent1 à¦“ parent2 à¦à¦•à¦‡ à¦¦à§ˆà¦°à§à¦˜à§à¦¯à§‡à¦° à¦•à¦¿à¦¨à¦¾à¥¤

à¦¯à¦¦à¦¿ à¦¨à¦¾ à¦¹à§Ÿ, à¦¤à¦¾à¦¹à¦²à§‡ error à¦¦à§‡à¦–à¦¾à§Ÿ à¦•à¦¾à¦°à¦£ à¦à¦•à¦‡ à¦¸à¦¾à¦‡à¦œ à¦¨à¦¾ à¦¹à¦²à§‡ à¦à¦•à¦¸à¦¾à¦¥à§‡ à¦®à¦¿à¦²à¦¿à§Ÿà§‡ offspring à¦¤à§ˆà¦°à¦¿ à¦•à¦°à¦¾ à¦¯à¦¾à¦¬à§‡ à¦¨à¦¾à¥¤

    crossover_point = random.randint(1, len(parent1) - 1)
à§§ à¦¥à§‡à¦•à§‡ len(parent1)-1 à¦à¦° à¦®à¦§à§à¦¯à§‡ à¦à¦•à¦Ÿà¦¿ random index à¦¨à¦¿à¦°à§à¦¬à¦¾à¦šà¦¨ à¦•à¦°à¦¾ à¦¹à§Ÿ à¦¯à§‡à¦–à¦¾à¦¨à§‡ crossover à¦¹à¦¬à§‡à¥¤

0 à¦¨à§‡à§Ÿ à¦¨à¦¾ à¦•à¦¾à¦°à¦£ à¦¸à§‡à¦Ÿà¦¿ à¦®à¦¾à¦¨à§‡ à¦ªà§à¦°à§‹ parent2 à¦¨à¦¿à§Ÿà§‡ à¦¨à§‡à¦“à§Ÿà¦¾, à¦¯à¦¾ à¦…à¦¬à¦¾à¦žà§à¦›à¦¿à¦¤à¥¤

    offspring1 = parent1[:crossover_point] + parent2[crossover_point:]
    offspring2 = parent2[:crossover_point] + parent1[crossover_point:]
offspring1: parent1-à¦à¦° à¦¶à§à¦°à§ à¦¥à§‡à¦•à§‡ crossover point à¦ªà¦°à§à¦¯à¦¨à§à¦¤ + parent2-à¦à¦° à¦¬à¦¾à¦•à¦¿ à¦…à¦‚à¦¶à¥¤

offspring2: à¦‰à¦²à§à¦Ÿà§‹à¦­à¦¾à¦¬à§‡ à¦•à¦°à¦¾ à¦¹à§Ÿà¥¤

ðŸ§ª à¦‰à¦¦à¦¾à¦¹à¦°à¦£
parent1 = [1, 0, 1, 1, 0]
parent2 = [0, 1, 0, 1, 1]
à¦§à¦°à¦¾ à¦¯à¦¾à¦• random crossover point à¦¹à§Ÿ 2, à¦¤à¦¾à¦¹à¦²à§‡:

offspring1 = parent1[:2] + parent2[2:]
= [1, 0] + [0, 1, 1] = [1, 0, 0, 1, 1]

offspring2 = parent2[:2] + parent1[2:]
= [0, 1] + [1, 1, 0] = [0, 1, 1, 1, 0]

ðŸ–¨ï¸ Output à¦¹à¦¤à§‡ à¦ªà¦¾à¦°à§‡:
Offspring 1: [1, 0, 0, 1, 1]
Offspring 2: [0, 1, 1, 1, 0]
ðŸŽ¯ à¦‰à¦ªà¦¸à¦‚à¦¹à¦¾à¦°:
Single Point Crossover à¦¸à¦¹à¦œ à¦•à¦¿à¦¨à§à¦¤à§ à¦•à¦¾à¦°à§à¦¯à¦•à¦°à§€ à¦à¦•à¦Ÿà¦¿ à¦ªà¦¦à§à¦§à¦¤à¦¿ Genetic Algorithm-à¦à¥¤

à¦à¦Ÿà¦¿ parent-à¦à¦° à¦­à¦¾à¦² à¦¦à¦¿à¦•à¦—à§à¦²à§‹ offspring-à¦ à¦¨à¦¿à§Ÿà§‡ à¦†à¦¸à§‡ à¦à¦¬à¦‚ à¦¨à¦¤à§à¦¨ à¦¬à§ˆà¦šà¦¿à¦¤à§à¦°à§à¦¯ à¦¤à§ˆà¦°à¦¿ à¦•à¦°à§‡à¥¤

Genetic diversity à¦¬à¦œà¦¾à§Ÿ à¦°à¦¾à¦–à¦¤à§‡ à¦à¦¬à¦‚ à¦†à¦°à¦“ à¦­à¦¾à¦²à§‹ à¦¸à¦®à¦¾à¦§à¦¾à¦¨à§‡ à¦ªà§Œà¦à¦›à¦¾à¦¤à§‡ à¦à¦‡ crossover à¦ªà¦¦à§à¦§à¦¤à¦¿ à¦—à§à¦°à§à¦¤à§à¦¬à¦ªà§‚à¦°à§à¦£à¥¤

à¦†à¦ªà¦¨à¦¿ à¦•à¦¿ à¦šà¦¾à¦¨ à¦à¦‡ à¦•à§à¦°à¦¸à¦“à¦­à¦¾à¦°à¦Ÿà¦¿à¦•à§‡ à¦†à¦ªà¦¨à¦¾à¦° N-Queens à¦•à§‹à¦¡à§‡à¦° à¦®à¦§à§à¦¯à§‡ à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à§‡ à¦¦à§‡à¦–à¦¾à¦‡?

You said:
def single_point_crossover(parent1, parent2):

    if len(parent1) != len(parent2):
        raise ValueError("Parents must have the same length.")

    crossover_point = random.randint(1, len(parent1) - 1)

    offspring1 = parent1[:crossover_point] + parent2[crossover_point:]
    offspring2 = parent2[:crossover_point] + parent1[crossover_point:]
    
    return offspring1, offspring2

parent1 = [1, 0, 1, 1, 0]
parent2 = [0, 1, 0, 1, 1]

offspring1, offspring2 = single_point_crossover(parent1, parent2)
print("Offspring 1:", offspring1)
print("Offspring 2:", offspring2)

PS C:\projects\Python\py practice> python -u "c:\projects\Python\py practice\singlePointGA.py"
Traceback (most recent call last):
  File "c:\projects\Python\py practice\singlePointGA.py", line 16, in <module>
    offspring1, offspring2 = single_point_crossover(parent1, parent2)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "c:\projects\Python\py practice\singlePointGA.py", line 6, in single_point_crossover
    crossover_point = random.randint(1, len(parent1) - 1)
                      ^^^^^^
NameError: name 'random' is not defined. Did you forget to import 'random'?
ChatGPT said:
à¦¤à§‹à¦®à¦¾à¦° à¦•à§‹à¦¡à§‡ NameError: name 'random' is not defined à¦à¦‡ à¦¤à§à¦°à§à¦Ÿà¦¿à¦° à¦®à¦¾à¦¨à§‡ à¦¹à¦²à§‹ à¦¤à§à¦®à¦¿ random à¦®à¦¡à¦¿à¦‰à¦²à¦Ÿà¦¿ import à¦•à¦°à§‹ à¦¨à¦¾à¦‡à¥¤ Python-à¦ à¦¯à¦–à¦¨à¦‡ à¦¤à§à¦®à¦¿ random.randint() à¦¬à¦¾ à¦…à¦¨à§à¦¯ à¦•à§‹à¦¨à§‹ random à¦«à¦¾à¦‚à¦¶à¦¨ à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à§‹, à¦¤à¦–à¦¨ à¦…à¦¬à¦¶à§à¦¯à¦‡ à¦‰à¦ªà¦°à§‡ import random à¦²à¦¿à¦–à§‡ à¦¦à¦¿à¦¤à§‡ à¦¹à§Ÿà¥¤

âœ… à¦ à¦¿à¦• à¦•à¦°à¦¾à¦° à¦‰à¦ªà¦¾à§Ÿ
à¦¤à§‹à¦®à¦¾à¦° à¦•à§‹à¦¡à§‡à¦° à¦à¦•à¦¦à¦® à¦¶à§à¦°à§à¦¤à§‡ (line 1 à¦) à¦¨à¦¿à¦šà§‡à¦° à¦²à¦¾à¦‡à¦¨à¦Ÿà¦¿ à¦¯à§‹à¦— à¦•à¦°à§‹:

import random
ðŸ”§ à¦¸à¦®à§à¦ªà§‚à¦°à§à¦£ à¦¸à¦‚à¦¶à§‹à¦§à¦¿à¦¤ à¦•à§‹à¦¡:
import random  # à¦à¦‡ à¦²à¦¾à¦‡à¦¨à¦Ÿà¦¿ à¦¯à§‹à¦— à¦•à¦°à¦¤à§‡ à¦­à§à¦²à§‡ à¦—à§‡à¦›à§‹

def single_point_crossover(parent1, parent2):
    if len(parent1) != len(parent2):
        raise ValueError("Parents must have the same length.")

    crossover_point = random.randint(1, len(parent1) - 1)

    offspring1 = parent1[:crossover_point] + parent2[crossover_point:]
    offspring2 = parent2[:crossover_point] + parent1[crossover_point:]
    
    return offspring1, offspring2

parent1 = [1, 0, 1, 1, 0]
parent2 = [0, 1, 0, 1, 1]

offspring1, offspring2 = single_point_crossover(parent1, parent2)
print("Offspring 1:", offspring1)
print("Offspring 2:", offspring2)
à¦à¦–à¦¨ à¦à¦‡ à¦•à§‹à¦¡à¦Ÿà¦¿ à¦šà¦²à¦¬à§‡ à¦ à¦¿à¦•à¦­à¦¾à¦¬à§‡ à¦à¦¬à¦‚ à¦à¦²à§‹à¦®à§‡à¦²à§‹à¦­à¦¾à¦¬à§‡ à¦à¦•à¦Ÿà¦¿ crossover point à¦¨à¦¿à§Ÿà§‡ offspring à¦¤à§ˆà¦°à¦¿ à¦•à¦°à¦¬à§‡à¥¤

à¦¤à§à¦®à¦¿ à¦•à¦¿ à¦šà¦¾à¦“ à¦à¦‡ crossover à¦ªà¦¦à§à¦§à¦¤à¦¿ integrate à¦•à¦°à§‡ à¦¦à§‡à¦‡ à¦¤à§‹à¦®à¦¾à¦° N-Queens genetic algorithm-à¦?

You said:
2. Mutation (Code Segment) ->  

def mutate(offspring):    """Applies mutation to the offspring"""
    mutation_rate = 0.01 # Adjust mutation rate as needed
    mutated_offspring = []
    for individual in offspring:
        mutated_individual = individual.copy() # Avoid modifying the original
        for gene_index in range(len(individual)):
            if random.random() < mutation_rate:
                mutated_individual[gene_index] = random.randint(0, 1) #Example: flipping a bit for binary genes
        mutated_offspring.append(mutated_individual)
    return mutated_offspring

ChatGPT said:
à¦šà¦²à§à¦¨ à¦à¦–à¦¨ à¦à¦‡ mutate à¦«à¦¾à¦‚à¦¶à¦¨à§‡à¦° à¦¬à§à¦¯à¦¾à¦–à§à¦¯à¦¾à¦Ÿà¦¿ à¦¬à¦¾à¦‚à¦²à¦¾à§Ÿ à¦§à¦¾à¦ªà§‡ à¦§à¦¾à¦ªà§‡ à¦•à¦°à¦¿:

ðŸ§¬ Mutation (à¦°à§‚à¦ªà¦¾à¦¨à§à¦¤à¦°) à¦•à§€?
Genetic Algorithm-à¦ mutation à¦¹à¦²à§‹ à¦à¦®à¦¨ à¦à¦•à¦Ÿà¦¿ à¦§à¦¾à¦ª à¦¯à§‡à¦–à¦¾à¦¨à§‡ offspring (à¦¸à¦¨à§à¦¤à¦¾à¦¨ à¦¸à¦®à¦¾à¦§à¦¾à¦¨)-à¦à¦° à¦®à¦§à§à¦¯à§‡ à¦›à§‹à¦Ÿà¦–à¦¾à¦Ÿà§‹ à¦ªà¦°à¦¿à¦¬à¦°à§à¦¤à¦¨ à¦•à¦°à¦¾ à¦¹à§Ÿà¥¤
ðŸ‘‰ à¦à¦° à¦‰à¦¦à§à¦¦à§‡à¦¶à§à¦¯ à¦¹à¦²à§‹ population-à¦ à¦¬à§ˆà¦šà¦¿à¦¤à§à¦°à§à¦¯ (diversity) à¦¬à¦œà¦¾à§Ÿ à¦°à¦¾à¦–à¦¾ à¦¯à¦¾à¦¤à§‡ algorithm local optimum-à¦ à¦†à¦Ÿà¦•à§‡ à¦¨à¦¾ à¦¯à¦¾à§Ÿà¥¤

âœ… à¦•à§‹à¦¡ à¦¬à§à¦¯à¦¾à¦–à§à¦¯à¦¾:
def mutate(offspring):
    """Applies mutation to the offspring"""
à¦à¦‡ à¦«à¦¾à¦‚à¦¶à¦¨à¦Ÿà¦¿ à¦à¦•à¦Ÿà¦¿ offspring list à¦¨à§‡à§Ÿ à¦à¦¬à¦‚ à¦ªà§à¦°à¦¤à§à¦¯à§‡à¦• offspring-à¦ à¦•à¦¿à¦›à§ mutation à¦ªà§à¦°à§Ÿà§‹à¦— à¦•à¦°à§‡à¥¤

    mutation_rate = 0.01 # Adjust mutation rate as needed
mutation_rate = 1%, à¦…à¦°à§à¦¥à¦¾à§Ž à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ gene-à¦à¦° à¦®à¦¾à¦¤à§à¦° 1% à¦¸à¦®à§à¦­à¦¾à¦¬à¦¨à¦¾ à¦†à¦›à§‡ à¦ªà¦°à¦¿à¦¬à¦°à§à¦¤à¦¿à¦¤ à¦¹à¦“à§Ÿà¦¾à¦°à¥¤

    mutated_offspring = []
à¦¨à¦¤à§à¦¨ mutated offspring à¦—à§à¦²à§‹ à¦°à¦¾à¦–à¦¾à¦° à¦œà¦¨à§à¦¯ à¦à¦•à¦Ÿà¦¿ à¦–à¦¾à¦²à¦¿ list à¦¤à§ˆà¦°à¦¿ à¦•à¦°à¦¾ à¦¹à§Ÿà§‡à¦›à§‡à¥¤

    for individual in offspring:
        mutated_individual = individual.copy() # Avoid modifying the original
à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ offspring-à¦à¦° à¦œà¦¨à§à¦¯:

à¦à¦•à¦Ÿà¦¿ copy à¦¤à§ˆà¦°à¦¿ à¦•à¦°à¦¾ à¦¹à¦šà§à¦›à§‡ à¦¯à¦¾à¦¤à§‡ à¦®à§‚à¦²à¦Ÿà¦¾ à¦ªà¦°à¦¿à¦¬à¦°à§à¦¤à¦¨ à¦¨à¦¾ à¦¹à§Ÿà¥¤

        for gene_index in range(len(individual)):
            if random.random() < mutation_rate:
                mutated_individual[gene_index] = random.randint(0, 1) 
à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ gene-à¦à¦° à¦œà¦¨à§à¦¯ (à¦¯à§‡à¦®à¦¨: binary bit, à¦¬à¦¾ à¦à¦•à¦Ÿà¦¿ value):

random.random() à¦à¦•à¦Ÿà¦¿ à¦¸à¦‚à¦–à§à¦¯à¦¾ à¦¦à§‡à§Ÿ 0.0 à¦¥à§‡à¦•à§‡ 1.0 à¦à¦° à¦®à¦§à§à¦¯à§‡à¥¤

à¦¯à¦¦à¦¿ à¦¤à¦¾ mutation rate-à¦à¦° à¦•à¦® à¦¹à§Ÿ (à¦¯à§‡à¦®à¦¨ 0.007 < 0.01), à¦¤à¦¾à¦¹à¦²à§‡:

à¦¸à§‡à¦‡ gene-à¦Ÿà¦¿ à¦¬à¦¦à¦²à§‡ à¦¦à§‡à¦“à§Ÿà¦¾ à¦¹à§Ÿ 0 à¦…à¦¥à¦¬à¦¾ 1 à¦¦à¦¿à§Ÿà§‡à¥¤

à¦…à¦°à§à¦¥à¦¾à§Ž bit flip à¦¹à§Ÿà¥¤

        mutated_offspring.append(mutated_individual)
mutated individual-à¦Ÿà¦¿ à¦²à¦¿à¦¸à§à¦Ÿà§‡ à¦¯à§‹à¦— à¦•à¦°à¦¾ à¦¹à§Ÿà¥¤

    return mutated_offspring
à¦¸à¦¬à¦—à§à¦²à§‹ mutation à¦¸à¦®à§à¦ªà¦¨à§à¦¨ à¦¹à¦²à§‡ à¦¸à§‡à¦Ÿà¦¿ return à¦•à¦°à§‡à¥¤

ðŸ”„ à¦‰à¦¦à¦¾à¦¹à¦°à¦£:
à¦§à¦°à¦¾ à¦¯à¦¾à¦•:

offspring = [[1, 0, 1, 1, 0], [0, 1, 1, 0, 1]]
Mutation rate 0.01 à¦¹à¦²à§‡, à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ bit-à¦à¦° à¦®à¦¾à¦¤à§à¦° 1% à¦¸à¦®à§à¦­à¦¾à¦¬à¦¨à¦¾à§Ÿ flip à¦¹à¦¬à§‡à¥¤
à¦•à§‹à¦¨à§‹ mutation à¦¨à¦¾-à¦“ à¦˜à¦Ÿà¦¤à§‡ à¦ªà¦¾à¦°à§‡à¥¤ à¦†à¦¬à¦¾à¦° 1à¦Ÿà¦¿ à¦¬à¦¾ 2à¦Ÿà¦¿ bit à¦¬à¦¦à¦²à¦¾à¦¤à§‡ à¦ªà¦¾à¦°à§‡à¥¤

ðŸ”§ à¦—à§à¦°à§à¦¤à§à¦¬à¦ªà§‚à¦°à§à¦£:
Binary chromosome-à¦ à¦¯à§‡à¦®à¦¨ random.randint(0, 1) à¦ à¦¿à¦• à¦†à¦›à§‡à¥¤

à¦•à¦¿à¦¨à§à¦¤à§ à¦¯à¦¦à¦¿ chromosome-à¦à¦° gene à¦…à¦¨à§à¦¯ à¦§à¦°à¦¨à§‡à¦° à¦¹à§Ÿ (à¦¯à§‡à¦®à¦¨ N-Queens problem à¦ 1 à¦¥à§‡à¦•à§‡ N à¦ªà¦°à§à¦¯à¦¨à§à¦¤ à¦¸à¦‚à¦–à§à¦¯à¦¾à§Ÿ), à¦¤à¦¾à¦¹à¦²à§‡ mutation à¦«à¦¾à¦‚à¦¶à¦¨à§‡ à¦à¦•à¦Ÿà§ à¦­à¦¿à¦¨à§à¦¨à¦­à¦¾à¦¬à§‡ à¦•à¦°à¦¤à§‡ à¦¹à¦¬à§‡à¥¤

à¦¤à§à¦®à¦¿ à¦•à¦¿ à¦à¦‡ mutation à¦«à¦¾à¦‚à¦¶à¦¨à¦Ÿà¦¿à¦•à§‡ N-Queens à¦à¦° à¦®à¦¤à§‹ non-binary chromosome-à¦à¦° à¦œà¦¨à§à¦¯ à¦ªà¦°à¦¿à¦¬à¦°à§à¦¤à¦¨ à¦•à¦°à§‡ à¦¦à¦¿à¦¤à§‡ à¦šà¦¾à¦“?

You said:
give me full code and explain it 
ChatGPT said:
Certainly! Here's the full working code for a Genetic Algorithm that uses single-point crossover and mutation (with adjustable mutation rate), suitable for binary chromosomes like [0, 1, 1, 0, 1].

âœ… Full Code: Genetic Algorithm with Single-Point Crossover & Mutation
import random

# ----- Create Initial Population -----
def generate_population(pop_size, chromosome_length):
    return [[random.randint(0, 1) for _ in range(chromosome_length)] for _ in range(pop_size)]

# ----- Fitness Function -----
def fitness(chromosome):
    # Example: maximize number of 1s (simple problem)
    return sum(chromosome)

# ----- Selection: Roulette Wheel Selection -----
def select_parent(population, fitnesses):
    total_fitness = sum(fitnesses)
    pick = random.uniform(0, total_fitness)
    current = 0
    for individual, fit in zip(population, fitnesses):
        current += fit
        if current >= pick:
            return individual
    return population[-1]

# ----- Single Point Crossover -----
def single_point_crossover(parent1, parent2):
    if len(parent1) != len(parent2):
        raise ValueError("Parents must have the same length.")
    crossover_point = random.randint(1, len(parent1) - 1)
    offspring1 = parent1[:crossover_point] + parent2[crossover_point:]
    offspring2 = parent2[:crossover_point] + parent1[crossover_point:]
    return offspring1, offspring2

# ----- Mutation -----
def mutate(offspring, mutation_rate=0.01):
    mutated_offspring = []
    for individual in offspring:
        mutated = individual.copy()
        for i in range(len(mutated)):
            if random.random() < mutation_rate:
                mutated[i] = 1 - mutated[i]  # Flip bit
        mutated_offspring.append(mutated)
    return mutated_offspring

# ----- Genetic Algorithm Main Function -----
def genetic_algorithm(pop_size=10, chromosome_length=8, generations=50, mutation_rate=0.01):
    population = generate_population(pop_size, chromosome_length)
    best_solution = None

    for gen in range(generations):
        print(f"\n--- Generation {gen + 1} ---")
        fitnesses = [fitness(ind) for ind in population]
        max_fit = max(fitnesses)
        best_solution = population[fitnesses.index(max_fit)]
        print(f"Best Fitness: {max_fit}, Chromosome: {best_solution}")

        new_population = []
        while len(new_population) < pop_size:
            # Selection
            parent1 = select_parent(population, fitnesses)
            parent2 = select_parent(population, fitnesses)

            # Crossover
            child1, child2 = single_point_crossover(parent1, parent2)

            # Mutation
            children = mutate([child1, child2], mutation_rate)

            new_population.extend(children)

        population = new_population[:pop_size]

    print(f"\nâœ… Final Best Solution: {best_solution}, Fitness: {fitness(best_solution)}")

# Run the algorithm
genetic_algorithm()
ðŸ“˜ Explanation in Bengali:
1. Initial Population Generation
generate_population(pop_size, chromosome_length)
à¦à¦•à¦Ÿà¦¿ population à¦¤à§ˆà¦°à¦¿ à¦•à¦°à§‡, à¦¯à§‡à¦–à¦¾à¦¨à§‡ à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ individual à¦à¦•à¦Ÿà¦¿ binary chromosome (à¦¯à§‡à¦®à¦¨ [0, 1, 1, 0, 1, 0, 1, 1])à¥¤

2. Fitness Function
def fitness(chromosome): return sum(chromosome)
à¦à¦–à¦¾à¦¨à§‡ fitness à¦¹à¦¿à¦¸à¦¾à¦¬ à¦•à¦°à¦¾ à¦¹à§Ÿ total 1 à¦¸à¦‚à¦–à§à¦¯à¦¾ à¦¦à¦¿à§Ÿà§‡à¥¤ à¦¯à¦¤ à¦¬à§‡à¦¶à¦¿ 1, à¦¤à¦¤ à¦­à¦¾à¦²à§‹à¥¤

3. Parent Selection
select_parent(population, fitnesses)
Roulette wheel method: à¦¬à§‡à¦¶à¦¿ fitness à¦¥à¦¾à¦•à¦²à§‡ parent à¦¹à¦“à§Ÿà¦¾à¦° à¦¸à¦®à§à¦­à¦¾à¦¬à¦¨à¦¾à¦“ à¦¬à§‡à¦¶à¦¿à¥¤

4. Single Point Crossover
single_point_crossover(parent1, parent2)
à¦¦à§à¦‡à¦Ÿà¦¿ parent à¦à¦° à¦®à¦¾à¦à¦–à¦¾à¦¨à§‡ à¦à¦•à¦Ÿà¦¿ random crossover point à¦¨à§‡à§Ÿ à¦à¦¬à¦‚ à¦¸à§‡à¦‡ à¦¬à¦¿à¦¨à§à¦¦à§ à¦¥à§‡à¦•à§‡ à¦¦à§à¦‡à¦Ÿà¦¿ offspring à¦¤à§ˆà¦°à¦¿ à¦•à¦°à§‡à¥¤

à¦‰à¦¦à¦¾à¦¹à¦°à¦£:

parent1 = [1, 0, 1, 1, 0]
parent2 = [0, 1, 0, 1, 1]
crossover_point = 2

offspring1 = [1, 0] + [0, 1, 1] = [1, 0, 0, 1, 1]
offspring2 = [0, 1] + [1, 1, 0] = [0, 1, 1, 1, 0]
5. Mutation
mutate(offspring, mutation_rate=0.01)
à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ bit 1% à¦¸à¦®à§à¦­à¦¾à¦¬à¦¨à¦¾à§Ÿ flip à¦¹à§Ÿà¥¤ à¦¯à§‡à¦®à¦¨ 1 â†’ 0, à¦…à¦¥à¦¬à¦¾ 0 â†’ 1à¥¤

6. Loop Over Generations
for gen in range(generations):
à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ generation à¦ à¦¨à¦¤à§à¦¨ population à¦¤à§ˆà¦°à¦¿ à¦¹à§Ÿ:

Selection â†’ Crossover â†’ Mutation

à¦¸à¦°à§à¦¬à§‹à¦šà§à¦š fitness à¦¸à¦¹ chromosome track à¦•à¦°à¦¾ à¦¹à§Ÿà¥¤

ðŸŽ¯ Output Example:
--- Generation 1 ---
Best Fitness: 6, Chromosome: [1, 1, 0, 1, 1, 0, 1, 1]

...

âœ… Final Best Solution: [1, 1, 1, 1, 1, 1, 1, 1], Fitness: 8
âœï¸ à¦šà¦¾à¦‡à¦²à§‡ à¦¤à§à¦®à¦¿ à¦à¦‡ GA-à¦•à§‡ à¦¨à¦¿à¦œà§‡à¦° à¦¸à¦®à¦¸à§à¦¯à¦¾ à¦…à¦¨à§à¦¯à¦¾à§Ÿà§€ à¦•à¦¾à¦¸à§à¦Ÿà¦®à¦¾à¦‡à¦œ à¦•à¦°à¦¤à§‡ à¦ªà¦¾à¦°à§‹:
fitness() à¦«à¦¾à¦‚à¦¶à¦¨ à¦ªà¦°à¦¿à¦¬à¦°à§à¦¤à¦¨ à¦•à¦°à§‡ à¦¨à¦¤à§à¦¨ à¦²à¦•à§à¦·à§à¦¯ à¦¦à§‡à¦“à§Ÿà¦¾,

Binary à¦à¦° à¦¬à¦¦à¦²à§‡ à¦…à¦¨à§à¦¯à¦¾à¦¨à§à¦¯ à¦§à¦°à¦¨à§‡à¦° gene à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à¦¾ (à¦¯à§‡à¦®à¦¨ N-Queens à¦à¦° à¦®à¦¤à§‹ à¦¸à¦‚à¦–à§à¦¯à¦¾),

à¦¬à¦¾ mutation rate à¦¬à¦¾à§œà¦¾à¦¨à§‹/à¦•à¦®à¦¾à¦¨à§‹à¥¤

à¦¤à§à¦®à¦¿ à¦•à¦¿ à¦à¦–à¦¨ à¦à¦‡ genetic algorithm à¦•à§‡ N-Queens problem à¦à¦° à¦œà¦¨à§à¦¯ à¦ªà¦°à¦¿à¦¬à¦°à§à¦¤à¦¨ à¦•à¦°à§‡ à¦¦à§‡à¦–à¦¤à§‡ à¦šà¦¾à¦“?

You said:
banglay bujao
ChatGPT said:
à¦¨à¦¿à¦¶à§à¦šà¦¿à¦¤à¦­à¦¾à¦¬à§‡! à¦¨à¦¿à¦šà§‡ à¦†à¦®à¦¿ à¦‰à¦ªà¦°à§‡à¦° Genetic Algorithm à¦•à§‹à¦¡-à¦à¦° à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ à¦…à¦‚à¦¶ à¦¬à¦¾à¦‚à¦²à¦¾à§Ÿ à¦¬à¦¿à¦¸à§à¦¤à¦¾à¦°à¦¿à¦¤à¦­à¦¾à¦¬à§‡ à¦¬à§à¦¯à¦¾à¦–à§à¦¯à¦¾ à¦•à¦°à§‡à¦›à¦¿:

ðŸ”¢ à¦•à§‹à¦¡à§‡à¦° à¦‰à¦¦à§à¦¦à§‡à¦¶à§à¦¯:
à¦à¦‡ à¦•à§‹à¦¡à¦Ÿà¦¾ à¦à¦•à¦Ÿà¦¾ à¦¸à¦¾à¦§à¦¾à¦°à¦£ Genetic Algorithm (GA) à¦¬à¦¾à¦¸à§à¦¤à¦¬à¦¾à§Ÿà¦¨ à¦•à¦°à§‡, à¦¯à§‡à¦Ÿà¦¾ binary chromosome à¦¨à¦¿à§Ÿà§‡ à¦•à¦¾à¦œ à¦•à¦°à§‡ â€” à¦¯à§‡à¦®à¦¨: [0, 1, 1, 0, 1]à¥¤ à¦à¦° à¦²à¦•à§à¦·à§à¦¯ à¦¹à¦šà§à¦›à§‡ à¦à¦®à¦¨ à¦à¦•à¦Ÿà¦¿ chromosome à¦–à§à¦à¦œà§‡ à¦¬à§‡à¦° à¦•à¦°à¦¾ à¦¯à§‡à¦–à¦¾à¦¨à§‡ à¦¸à¦¬ gene 1 (à¦¯à§‡à¦®à¦¨ [1, 1, 1, 1, 1, 1, 1, 1])à¥¤

ðŸ”§ à¦§à¦¾à¦ªà¦­à¦¿à¦¤à§à¦¤à¦¿à¦• à¦¬à§à¦¯à¦¾à¦–à§à¦¯à¦¾:
à§§. Initial Population à¦¤à§ˆà¦°à¦¿ (à¦¶à§à¦°à§à¦¤à§‡ à¦•à¦¿à¦›à§ à¦¸à¦®à¦¾à¦§à¦¾à¦¨ à¦¬à¦¾à¦¨à¦¾à¦¨à§‹):
def generate_population(pop_size, chromosome_length):
    return [[random.randint(0, 1) for _ in range(chromosome_length)] for _ in range(pop_size)]
ðŸ‘‰ à¦§à¦°à§‹ à¦¤à§à¦®à¦¿ à§§à§¦à¦Ÿà¦¾ à¦¸à¦®à¦¾à¦§à¦¾à¦¨ (population) à¦¨à¦¿à¦¤à§‡ à¦šà¦¾à¦“, à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¾ à¦¸à¦®à¦¾à¦§à¦¾à¦¨ à§®à¦Ÿà¦¾ à¦¬à¦¿à¦Ÿ à¦¨à¦¿à§Ÿà§‡ à¦¤à§ˆà¦°à¦¿à¥¤ à¦¯à§‡à¦®à¦¨:
[1, 0, 1, 1, 0, 0, 1, 1]
à¦à¦­à¦¾à¦¬à§‡ à¦…à¦¨à§‡à¦•à¦—à§à¦²à§‹ random à¦¸à¦®à¦¾à¦§à¦¾à¦¨ à¦¬à¦¾à¦¨à¦¾à§Ÿà¥¤

à§¨. Fitness





Search

Reason

Deep research

Create image



No file chosenNo file chosen
ChatGPT can make mistakes. Check important info.
